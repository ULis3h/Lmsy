import requests
from urllib.parse import urlparse, urlencode

def check_redirect_vulnerability(base_url, param_name="url", test_url="http://evil.com"):
    """
    检测单个URL是否存在跳转漏洞
    :param base_url: 待检测的目标URL
    :param param_name: 可控的参数名，默认是 "url"
    :param test_url: 用于测试跳转的恶意URL
    :return: 检测结果 (是否存在漏洞, 响应状态码)
    """
    try:
        # 构造测试URL
        parsed_url = urlparse(base_url)
        query = {param_name: test_url}
        test_redirect_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urlencode(query)}"
        
        # 发送请求
        response = requests.get(test_redirect_url, allow_redirects=False, timeout=5)

        # 检测是否存在跳转漏洞
        if response.status_code in [301, 302, 303, 307, 308]:
            # 检查响应头中的 Location 是否指向 test_url
            if "Location" in response.headers and test_url in response.headers["Location"]:
                return True, response.status_code
        elif test_url in response.text:
            # 如果响应内容中包含 test_url，也可能存在漏洞
            return True, response.status_code

        return False, response.status_code
    except Exception as e:
        print(f"检测 {base_url} 时出错: {e}")
        return False, None


def batch_check(url_list, param_name="url", test_url="http://evil.com"):
    """
    批量检测URL跳转漏洞
    :param url_list: 待检测的URL列表
    :param param_name: 可控的参数名
    :param test_url: 用于测试跳转的恶意URL
    """
    print("开始批量检测URL跳转漏洞...")
    for url in url_list:
        is_vulnerable, status_code = check_redirect_vulnerability(url, param_name, test_url)
        if is_vulnerable:
            print(f"[漏洞存在] {url} (状态码: {status_code})")
        else:
            print(f"[安全] {url} (状态码: {status_code})")


if __name__ == "__main__":
    # 示例URL列表
    urls_to_check = [
        "https://example.com/redirect",
        "https://example.com/login",
        "https://example.com/go"
    ]

    # 开始批量检测
    batch_check(urls_to_check)